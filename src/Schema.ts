import * as t from './Type';
import { Iso, Getter } from './Monocle';
import { flatten, array } from './Array';
import { isNil, isArray } from './predicate';
import { compareParams } from './Compare';
const typeName = t.union([t.RBasicTypeEnum, t.string]);
const propertyType = t.union([typeName, t.array(typeName)]);
type PropertyType = t.TypeOf<typeof propertyType>;
export const RProperty = t.intersection([
    t.type({
        /**
         * Property name.
         */
        name: t.string,
        /**
         * Property type.
         */
        type: t.withDefault(propertyType, 'string'),

    }),
    t.partial({
        /**
         * Whether a value for the property is required.
         */
        required: t.boolean,
        /**
         * Whether the property is a unique identifier
         */
        id: t.boolean,
        /**
         * Whether the property is a unique identifier
         */
        unique: t.boolean,
        /**
         * Documentation for the property.
         */
        description: t.string,

        /**
         * Default value for the property
         */
        defaultValue: t.any,
        /**
         * Whether the property represents a column (field) that is a database index
         */
        index: t.boolean,

        /**
         * The value will be automatically generated by the server,can't modify.
         */
        readonly: t.boolean,
        /**
         * Data length
         */
        length: t.Integer,
        /**
         * Data max value
         */
        min: t.number,
        /**
         * Data min value
         */
        max: t.number,
    }),
]);

export const RPropertyLens = t.lensesFromIntersection(RProperty);

/**
 * The Property static Type
 */
export type TProperty = t.TypeOf<typeof RProperty>;

/**
 * The Schema runtime type
 */
export const RSchema = t.intersection([
    t.interface({
        /**
         * Name of the model.
         */
        name: t.string,
        /**
         * JSON object that specifies the properties
         */
        properties: t.array(RProperty),

    }),

    t.partial({
        /**
         * If it is set to true it prevents users from setting the auto-id value manually.
         */
        forceId: t.boolean,
        /**
         * Specifies whether the model accepts only predefined properties
         */
        strict: t.boolean,
        /**
         * description of the model.
         */
        description: t.string,
        /**
         * Plural form of the model name.
         */
        plural: t.string,
        /**
         * Name of another model that this model extends.
         */
        base: t.string,

        /**
         * Set of ACL specifications that describes access control for the model.
         */
        acls: t.string,
        /**
         * Scopes enable you to specify commonly-used queries that you can reference as method calls on a model.
         */
        scopes: t.array(t.string),
        /**
         * A hidden property is not sent in the JSON data in the applicationâ€™s HTTP response.
         */
        hidden: t.array(t.string),
        /**
         * The protected property is an array of strings,
         * and each string in the array must match a property name defined for the model.
         */
        protected: t.array(t.string),
        /**
         * Excludes the given list of properties from the base model from being visible.
         */
        excludeBaseProperties: t.array(t.string),
        /**
         * Excludes the given list of properties from the base model from being visible.
         */
        type: t.union([t.literal('view'), t.literal('stand')]),
    }),
]);
export const RSchemaLens = t.lensesFromIntersection(RSchema);

/**
 * The Schema static Type
 */
export type TSchema = t.TypeOf<typeof RSchema>;

export const encodeAfter = (s: TSchema) => {
    const idP = s.properties.find(p => !!p.id);
    if (isNil(idP) && s.type !== 'view') {
        s.properties.push({
            name: 'id',
            type: 'string',
            id: true,
            required: true,
            unique: true,
        });
    }
    return s;
};

/**
 * get TSchema with object.
 * @param _schema
 */
export const fromObject = (_schema: any): TSchema => encodeAfter(
    t.decodeFromAny(RSchema, _schema));

/**
 * get ID name
 * @param s
 */
export const getIDName = (s: TSchema) => {
    const idP = s.properties.find(a => !!a.id);
    if (isNil(idP)) {
        throw new Error(`id can't found in ${s.name}`);
    }
    return idP.name;
};
/**
 * If container the given type
 * @param s
 * @param name
 */
export const containerType = (s: TSchema, name: string) =>
    s.properties.filter(a => isArray(a.type) ? a.type.includes(name) : a.type === name).length > 0;
/**
 * verify a Schema is recursive
 * @param s
 */
export const isRecursive = (s: TSchema) => containerType(s, s.name);

export const covertWhereSchema = (s: TSchema) => RSchemaLens.props.name.modify(a => a + 'Where')(s);

export type PropertyParseType = {
    name: t.TBasicTypeEnum | string;
    isIdentifier: boolean;
    isArray: boolean;
};

export const typeToParseType = new Iso<PropertyType, PropertyParseType>(type => {
    let name = 'string';
    if (isArray(type)) {
        if (type.length > 0) {
            name = type[0];
        }
    } else {
        name = type;
    }
    return {
        name,
        isArray: isArray(type),
        isIdentifier: !t.RBasicTypeEnum.is(name),
    };
}, type => type.isArray ? [type.name] : type.name);

/**
 * get property where
 */
export const propertyWhereGetter = new Getter<TProperty, TProperty[]>(p => {
    const type = typeToParseType.get(p.type);
    if (type.isArray && t.RBasicTypeEnum.is(type.name)) {
        return Object.entries(compareParams.array(type.name)).map(([a, b]) =>
            ({ name: `${p.name}_${a}`, type: b }));
    } else if (t.RBasicTypeEnum.is(type.name)) {
        return Object.entries(compareParams[type.name])
            .map(([a, b]) => ({ name: `${p.name}_${a}`, type: b }));
    } else {
        return [];
    }
});
/**
 * get schema where with schema
 */
export const schemaWhereGetter = new Getter<TSchema, TSchema>(p =>
    ({
        name: `${p.name}WhereInput`,
        properties: array.alt([{
            name: 'AND',
            type: `${p.name}WhereInput`,
        }, {
            name: 'OR',
            type: `${p.name}WhereInput`,
        },
        ], flatten(p.properties.map(propertyWhereGetter.get))),
    }));
