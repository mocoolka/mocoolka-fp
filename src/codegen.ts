export * from 'io-ts-codegen';
import * as tCode from './TypeGen';
import * as t from './Type';
import { } from './Collection';
import { isNil } from './predicate';
import * as basicType from './BasicType';
/**
 * Property type enum
 */
export const RTypes = t.union([
    t.literal('string'),
    t.literal('number'),
    t.literal('boolean'),
    t.literal('int'),
    t.literal('dateFromISOString'),
    t.literal('dateFromNumber'),
    t.literal('object'),
]);
export type TTypes = t.OutputOf<typeof RTypes>;

/* export const DateFromISOString = tCode.identifier('t.DateFromISOString');
export const DateFromNumber = tCode.identifier('t.DateFromNumber'); */
/**
 * Property runtime type
 */
export const RProperty = t.intersection([
    t.type({

    }),
    t.partialDefault({
        /**
         * Property type.
         */
        type: t.withDefault(basicType.basicTypeFromString, 'string'),
        /**
         * Whether a value for the property is required.
         */
        required: t.withDefault(t.boolean, false),
        /**
         * Whether the property is a unique identifier
         */
        id: t.withDefault(t.boolean, false),
        /**
         * Whether the property is a unique identifier
         */
        unique: t.withDefault(t.boolean, false),
    }),
    t.partial({
        /**
         * Documentation for the property.
         */
        description: t.string,

        /**
         * Default value for the property
         */
        defaultValue: t.any,
        /**
         * Whether the property represents a column (field) that is a database index
         */
        index: t.boolean,

        /**
         * The value will be automatically generated by the server,can't modify.
         */
        readonly: t.boolean,
        /**
         * Data length
         */
        length: t.Integer,
        /**
         * Data max value
         */
        min: t.number,
        /**
         * Data min value
         */
        max: t.number,
    }),
]);

export const RPropertyLens = t.lensesFromIntersection(RProperty);
/**
 * The Property static Type
 */
export type TProperty = t.TypeOf<typeof RProperty>;
/**
 * The Property input static type.
 */
export type TOutProperty = t.OutputOf<typeof RProperty>;

/**
 * The Schema runtime type
 */
export const RSchema = t.intersection([
    t.type({
        /**
         * Name of the model.
         */
        name: t.string,
        /**
         * JSON object that specifies the properties
         */
        properties: t.dictionary(t.string, RProperty),
    }),
    t.partialDefault({
        /**
         * Whether to automatically add an id property to the mode
         */
        idInjection: t.withDefault(t.boolean, true),
        /**
         * If it is set to true it prevents users from setting the auto-id value manually.
         */
        forceId: t.withDefault(t.boolean, true),
        /**
         * Specifies whether the model accepts only predefined properties
         */
        strict: t.withDefault(t.boolean, true),
    }),
    t.partial({
        /**
         * description of the model.
         */
        description: t.string,
        /**
         * Plural form of the model name.
         */
        plural: t.string,
        /**
         * Name of another model that this model extends.
         */
        base: t.string,

        /**
         * Set of ACL specifications that describes access control for the model.
         */
        acls: t.string,
        /**
         * Scopes enable you to specify commonly-used queries that you can reference as method calls on a model.
         */
        scopes: t.array(t.string),
        /**
         * A hidden property is not sent in the JSON data in the applicationâ€™s HTTP response.
         */
        hidden: t.array(t.string),
        /**
         * The protected property is an array of strings,
         * and each string in the array must match a property name defined for the model.
         */
        protected: t.array(t.string),
        /**
         * Excludes the given list of properties from the base model from being visible.
         */
        excludeBaseProperties: t.array(t.string),
    }),
]);
export const RSchemaLens = t.lensesFromIntersection(RSchema);
/**
 * The Schema static Type
 */
export type TSchema = t.TypeOf<typeof RSchema>;
/**
 * The Schema static input type.
 */
export type TInputSchema = t.InputOf<typeof RSchema>;

export type TOutputSchema = t.OutputOf<typeof RSchema>;

const getRequiredProperties = (schema: TSchema): string[] =>
    Object.entries(schema.properties).filter(([_, v]) => v.required).map(([key]) => key);
const getOptionalProperties = (schema: TSchema): string[] =>
    Object.entries(schema.properties).filter(([_, v]) => !v.required && isNil(v.defaultValue)).map(([key]) => key);
const getOptionalDefaultProperties = (schema: TSchema): string[] =>
    Object.entries(schema.properties).filter(([_, v]) => !v.required && !isNil(v.defaultValue)).map(([key]) => key);

/**
 * schema to type declaration
 */
const toTypeDeclaration = (schema: TSchema): tCode.TypeDeclaration => {
    const required = getRequiredProperties(schema);
    const optional = getOptionalProperties(schema);
    const optionalDefault = getOptionalDefaultProperties(schema);
    const combinator = schema.strict ? tCode.strictCombinator : tCode.interfaceCombinator;
    return tCode.typeDeclaration(
        schema.name,
        tCode.intersectionCombinator([
            combinator(
                required.map(key =>
                    tCode.property(key,
                        schema.properties[key].type,
                        false,
                        schema.properties[key].defaultValue,
                        schema.properties[key].description)
                ) as tCode.Property[]
            ),
            tCode.partialDefaultCombinator(
                optionalDefault.map(key =>
                    tCode.property(key,
                        schema.properties[key].type,
                        false,
                        schema.properties[key].defaultValue,
                        schema.properties[key].description)
                ) as tCode.Property[]
            ),
            tCode.partialCombinator(
                optional.map(key =>
                    tCode.property(key,
                        schema.properties[key].type,
                        true,
                        schema.properties[key].defaultValue,
                        schema.properties[key].description)
                )
            ),
        ])
        , true
    );
};

/**
 * The property covert to declaration
 * @param schema
 */
/* export function to(schema: t.mixed | null | undefined): tCode.TypeReference {
    switch (schema) {
        case 'string':
            return tCode.stringType;
        case 'number':
            return tCode.numberType;
        case 'boolean':
            return tCode.booleanType;
        case 'int':
            return tCode.integerType;
        case 'any':
            return tCode.anyType;
        case 'dateFromNumber':
            return tCode.dateFromNumber;
        case 'dateFromISOString':
            return tCode.dateFromISOString;
        case 'anyArray':
            return tCode.anyArrayType;
        case 'anyDictionary':
            return tCode.anyDictionaryType;
        case 'object':
            return tCode.objectType;
        default:
            return tCode.stringType;

    }
} */
export const exampleData = (schema: TSchema) => {
    Object.entries(schema.properties).forEach(([key, value]) => {
        RPropertyLens.props.type.get(value);
    });
    // RSchemaLens.props.properties..compose(RPropertyLens.props.required)

};

export class ModelCodegen {
    schema: TSchema;
    constructor(_schema: any) {
        this.schema = t.decodeFromAny(RSchema, _schema);
    }
    printStatic = () => {
        return tCode.printStatic(toTypeDeclaration(this.schema));
    }
    printRuntime = () => {
        return tCode.printRuntime(toTypeDeclaration(this.schema));
    }
}
export const fromSchema = (schema: any) => {
    return new ModelCodegen(schema);
};
