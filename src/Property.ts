import * as t from './Type';
import { isNil } from './predicate';
import { Getter } from './Monocle';

export const RProperty = t.intersection([
    t.type({

    }),
    t.partialDefault({

        /**
         * Property type.
         */
        type: t.withDefault(t.RBasicTypeEnum, 'string'),
        /**
         * Whether a value for the property is required.
         */
        required: t.withDefault(t.boolean, false),
        /**
         * Whether the property is a unique identifier
         */
        id: t.withDefault(t.boolean, false),
        /**
         * Whether the property is a unique identifier
         */
        unique: t.withDefault(t.boolean, false),
    }),
    t.partial({
        /**
         * Documentation for the property.
         */
        description: t.string,

        /**
         * Default value for the property
         */
        defaultValue: t.any,
        /**
         * Whether the property represents a column (field) that is a database index
         */
        index: t.boolean,

        /**
         * The value will be automatically generated by the server,can't modify.
         */
        readonly: t.boolean,
        /**
         * Data length
         */
        length: t.Integer,
        /**
         * Data max value
         */
        min: t.number,
        /**
         * Data min value
         */
        max: t.number,
    }),
]);

export const RPropertyLens = t.lensesFromIntersection(RProperty);

/**
 * The Property static Type
 */
export type TParseProperty = t.TypeOf<typeof RProperty>;

/**
 * The Property static Type
 */
export type TProperty = TParseProperty &
    { name: string; isDefaultOptional: boolean; isOptional: boolean };

export const PropertyGetterFromParseProperty = new Getter<[string, TParseProperty], TProperty>
    (([name, _value]) =>
        Object.assign({}, _value,
            {
                name,
                isDefaultOptional: !isNil(_value.defaultValue) && !_value.required,
                isOptional: !_value.required && isNil(_value.defaultValue),
            })
    );

/* export class Property {
    readonly kind: 'property' = 'property';
    readonly name: string = 'property';
    readonly value: TProperty &
        { name: string; isDefaultOptional: boolean; isOptional: boolean };

    constructor(name: string, _value: TProperty) {
        this.value = Object.assign({}, _value,
            {
                name,
                isDefaultOptional: !isNil(_value.defaultValue) && !_value.required,
                isOptional: !_value.required && isNil(_value.defaultValue),
            });
    }
} */
/* const printStaticProperty = (p: Property, i: number): string =>
    `${printDescription(p.value.description, i)}${indent(i)}
${escapePropertyKey(p.value.name)}${p.value.isOptional ? '?' : ''}: ${p.value.type.printStatic(i)}`;

function printRuntimeProperty(p: Property, i: number): string {
    const rType = p.value.type.printRuntime(i);
    const printType = p.value.defaultValue ? `t.withDefault(${rType}, ${p.value.defaultValue})` : rType;
    return `${printDescription(p.value.description, i)}${indent(i)}${escapePropertyKey(p.value.name)}: ${printType}`;
} */

// export const fromKeyValue = ([name, value]: [string, TProperty]) => new Property(name, value);
